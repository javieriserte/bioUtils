package utils.mutualinformation.misticmod;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import cmdGA.Parser;
import cmdGA.SingleOption;
import cmdGA.exceptions.IncorrectParameterTypeException;
import cmdGA.parameterType.DoubleParameter;
import cmdGA.parameterType.InputStreamParameter;
import cmdGA.parameterType.PrintStreamParameter;

/**
 * Given a MI_data file, generated by MISTIC, keeps top n% MI values, and replaces the rest of values by -999.
 * To direct Cytoscape and circos to do not taken them into account.   
 * 
 * 
 * @author javier
 *
 */
public class KeepTopMIData {

	/**
     * @param args
	 * @throws IOException 
	 */
	public static void main(String[] args) throws IOException {

		Parser parser = new Parser();
		
		SingleOption inOpt = new SingleOption(parser, System.in, "-infile", InputStreamParameter.getParameter());
		
		SingleOption outopt = new SingleOption(parser, System.out, "-outfile", PrintStreamParameter.getParameter());
		
		SingleOption topPercentOpt = new SingleOption(parser, null, "-toppercent", DoubleParameter.getParameter());
		
		try {
			
			parser.parseEx(args);
			
		} catch (IncorrectParameterTypeException e) {
			
			e.printStackTrace();
			
		}
	
		PrintStream out = (PrintStream) outopt.getValue();

		BufferedReader in = new BufferedReader(new InputStreamReader((InputStream)inOpt.getValue()));

		KeepTopMIData ktm = new KeepTopMIData();
		
		List<MI_Position> MI_Data_Lines = new ArrayList<MI_Position>();

		List<Double> values;
		
		String currentline = null;
		
		while ((currentline=in.readLine())!=null) {
		
			String[] data = currentline.split("\t");
		
			
			MI_Data_Lines.add(ktm.new MI_Position(Integer.valueOf(data[0]), Integer.valueOf(data[2]), data[1], data[3], Double.valueOf(data[4])));
		
		}
		
		values = ktm.extractMIvalues(MI_Data_Lines);
		
		values = ktm.filterMinusInfvalues(values);
		
		Comparator<Double> comparator = new Comparator<Double>() {

			@Override
			public int compare(Double o1, Double o2) {
				
				return (int) (o2-o1);
				
			}
			
		};
		
		Collections.sort(values, comparator);
		
		int top_n = (int) (((Double) topPercentOpt.getValue()) * values.size());
		
		double top_cutoff = values.get(top_n);
		
		for (MI_Position pos : MI_Data_Lines) {
			
			if (pos.mi<top_cutoff) {

				pos.mi = -999.99d;
				
			}
			
			out.println(pos);
		}
		
		out.flush();
		out.close();
		
	}

	/**
	 * eliminates from the list of MI values those that are not minus infinity (given by -999 number in the files generated by MISTIC)
	 * 
	 * 
	 * @param values
	 * @return
	 */
	private List<Double> filterMinusInfvalues(List<Double> values) {
		List<Double> result = new ArrayList<Double>();
		
		for (Double value : values) {
			
			if (value>=-999) {
				
				result.add(value);
				
			}
			
		}

		return result;
	}

	/**
	 * reads a MI_data file generated by MISTIC and returns the values column 
	 * 
	 * @param mI_Data_Lines
	 * @return
	 */
	private List<Double> extractMIvalues(List<MI_Position> mI_Data_Lines) {
		List<Double> result = new ArrayList<Double>();
		
		for (MI_Position pos : mI_Data_Lines) {
			
			result.add(pos.mi);
			
		}
		
		
		return result;
	}
	
	/**
	 * A class to manage data from MI_data generated by MISTIC
	 * 
	 * @author javier
	 *
	 */
	class MI_Position {
		int pos1;
		int pos2;
		String aa1;
		String aa2;
		Double mi;
		
		public MI_Position(int pos1, int pos2, String aa1, String aa2, Double mi) {
			super();
			this.pos1 = pos1;
			this.pos2 = pos2;
			this.aa1 = aa1;
			this.aa2 = aa2;
			this.mi = mi;
		}

		@Override
		public String toString() {
			return this.pos1 + "\t" + this.aa1 + "\t" + this.pos2 + "\t" + this.aa2+ "\t" + this.mi;
		}
		
		
		
	}
	

}
