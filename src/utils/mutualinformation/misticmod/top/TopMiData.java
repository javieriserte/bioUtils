package utils.mutualinformation.misticmod.top;

import io.bufferreaders.UncommenterBufferedReader;
import io.onelinelister.OneLineListReader;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.List;

import utils.mutualinformation.misticmod.datastructures.MI_Position;
import utils.mutualinformation.misticmod.datastructures.MI_PositionLineParser;
import utils.mutualinformation.misticmod.datastructures.MI_Position_MortemPrinter;
import cmdGA2.CommandLine;
import cmdGA2.MultipleArgumentOption;
import cmdGA2.NoArgumentOption;
import cmdGA2.OptionsFactory;
import cmdGA2.SingleArgumentOption;
import cmdGA2.returnvalues.OutfileValue;

/**
 * Reads MI data generated by MISTIC or Mortem soft.
 * Filter the values to keep the top MI pairs.
 * Top value cut-off can be set as a single MI value, 
 * a percentage or a fixed number of pairs.
 * 
 * @author Javier Iserte
 */
public class TopMiData {

	public static void main(String[] args) {
		
		////////////////////////////////////////
		// Create Command line 
		CommandLine cmd = new CommandLine();
		////////////////////////////////////////
		
		////////////////////////////////////////
		// Add Command line options
		SingleArgumentOption<InputStream>     inOpt = OptionsFactory.createBasicInputStreamArgument(cmd);
		SingleArgumentOption<String>   outPrefixOpt = OptionsFactory.createBasicStringArgument(cmd, "--prefix", "filtered_");
		SingleArgumentOption<String>    outSufixOpt = OptionsFactory.createBasicStringArgument(cmd, "--suffix", "_data");
		SingleArgumentOption<File>     outFolderOpt = new SingleArgumentOption<File>(cmd, "--outfolder", new OutfileValue(), new File(""));
		MultipleArgumentOption<MiFilter>  filterOpt = new MultipleArgumentOption<MiFilter>(cmd, "--filters", ',', null, new MIFilterReturnValue());
		NoArgumentOption                unwantedOpt = new NoArgumentOption(cmd, "--removeUnwanted");
		NoArgumentOption                    helpOpt = new NoArgumentOption(cmd, "--help");
		////////////////////////////////////////

		////////////////////////////////////////
		// Parse Command Line
		cmd.readAndExitOnError(args);
		////////////////////////////////////////
		
		////////////////////////////////////////
		// Check if help flat is present
		if (helpOpt.isPresent()) {
			System.err.println(TopMiData.getHelp());
			System.exit(0);
		}
		////////////////////////////////////////
		
		////////////////////////////////////////
		// Get Command line options
		BufferedReader in = new UncommenterBufferedReader(new InputStreamReader(inOpt.getValue()));
		File outFolder = outFolderOpt.getValue();
		
		String outPrefix = outPrefixOpt.getValue();
		String outSuffix  = outSufixOpt.getValue();
		
		if (!filterOpt.isPresent()) {
			System.err.println("--filter option is mandatory.");
			System.exit(0);
		}
		List<MiFilter> filters = filterOpt.getValues();
		UnwantedManager unwanted = unwantedOpt.isPresent()?new RemoveUnwanted():new KeepUnwanted();
		////////////////////////////////////////
		
		////////////////////////////////////////
		// Read MI data and export results
		MI_Position_MortemPrinter printer = new MI_Position_MortemPrinter();
		// Creates a string printer for MI data with the desired output format
		try {
			List<MI_Position> miData = (new OneLineListReader<MI_Position>(new MI_PositionLineParser())).read(in);
		//  Read input Data
			for (MiFilter filter : filters) {
		// Uses one filter at time
				File currentOutFile = new File(outFolder.getAbsoluteFile(), outPrefix + filter.getFormattedTagName() + outSuffix);
		// Set the output file
				PrintStream printOutfile = new PrintStream(currentOutFile);
		// Creates a print stream to the output file.
				List<MI_Position> filtered = filter.filter(unwanted, miData);
		// Filter MI positions 
				for (MI_Position mi_Position : filtered) {
					printOutfile.println(printer.print(mi_Position));
		// Export to output file one position at time
				}
				printOutfile.close();
		// Close the print stream to the output file
			}
		} catch (IOException e) {
			System.err.println("There was an error while reading input MI Data: "+ e.getMessage());
			System.exit(0);
		}
		////////////////////////////////////////
		
	}

	////////////////////////////////////////////
	// Class Methods
	private static String getHelp() {
		BufferedReader br = new BufferedReader (new InputStreamReader(TopMiData.class.getResourceAsStream("help")));
		StringBuilder sb = new StringBuilder();
		int c = -1;
		try {
			while ( (c = br.read())>=0) {
				sb.append((char)c);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		return sb.toString();
	}
	////////////////////////////////////////////

}
