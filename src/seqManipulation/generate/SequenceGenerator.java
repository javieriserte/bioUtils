package seqManipulation.generate;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;

import cmdGA2.CommandLine;
import cmdGA2.NoArgumentOption;
import cmdGA2.OptionsFactory;
import cmdGA2.SingleArgumentOption;

public class SequenceGenerator {

	private List<Segment> segments;
	// list of the segment for create the new sequences
	// each sequence is generatef by concatenation of the 
	// sequences generated by the different segments.
	// Each segment can generate sequence according to different
	// dsitributions.
	
	public static void main(String[] args) {

		//////////////////////////////////
		// Create command line object
		CommandLine cmdline = new CommandLine();
		
		////////////////////////////////////
		// Add command line arguments
		SingleArgumentOption<PrintStream> outOpt = OptionsFactory.createBasicPrintStreamArgument(cmdline);
		
		SingleArgumentOption<Integer> manyOpt = OptionsFactory.createBasicIntegerArgument(cmdline, "--many", 10);
		
		SingleArgumentOption<String> prefixOpt = OptionsFactory.createBasicStringArgument(cmdline, "--prefix", "seq");

		NoArgumentOption isProtOpt = new NoArgumentOption(cmdline, "--isprotein");
		
		NoArgumentOption noUniformOpt = new NoArgumentOption(cmdline, "--nouniform");
		
		SingleArgumentOption<Integer> lengthOpt = OptionsFactory.createBasicIntegerArgument(cmdline, "--length", 100);
		
		/////////////////////////////////////
		// Parse Command line
		cmdline.readAndExitOnError(args);
		
		//////////////////////////////////////
		// Get values from command line
		PrintStream out = outOpt.getValue();
		
		int many = manyOpt.getValue();
		
		String prefix = prefixOpt.getValue();
		
		int length = lengthOpt.getValue();
		
		//////////////////////////////////////
		// Validate command line
		 if (!isProtOpt.isPresent() && noUniformOpt.isPresent()) {
			 
			 System.err.println("DNA sequence only can be generated with uniform distribution at the moment");
			 
			 System.exit(1);
			 
		 }
		 
		SequenceGenerator generator = new SequenceGenerator();
		
		Segment segment = null;
		
		if (isProtOpt.isPresent() && noUniformOpt.isPresent()) {
			
			DistributionRandomSegment tmp = new DistributionRandomSegment(length);
			
			tmp.setSymbolDistributionUniProtKBProteins();
			
			segment = tmp;
			
		} else 
			
		if (isProtOpt.isPresent() && !noUniformOpt.isPresent()) {
				
			UniformRandomSegment tmp = new UniformRandomSegment(length);
				
			tmp.setProteinCharacters();
				
			segment = tmp;
				
		} else 

		if (!isProtOpt.isPresent() && !noUniformOpt.isPresent()) {
			
			UniformRandomSegment tmp = new UniformRandomSegment(length);
				
			tmp.setDNACharacters();
				
			segment = tmp;
				
		}

		generator.addSegment(segment);

		String desc;
		
		List<String> seq = generator.generateManySequences(many);
		
		int numberlength = 1+ (int)Math.log10(many);
		
		for (int i = 1; i<= many; i++ ) {
			
			desc = String.format("%s_%0"+numberlength+"d", prefix,i);

			out.println(">"+desc);
			
			out.println(seq.get(i-1));
			
		}
		
		out.flush();
		
		out.close(); 
		
		
	}

	/////////////////////////////////////
	// Constructor
	/**
	 * Creates a new SequenceGenerator
	 */
	public SequenceGenerator() {
		super();
		this.setSegments(new ArrayList<Segment>());
	}

	////////////////////////////////////
	// Public interface
	/**
	 * Generate a single sequence.
	 */
	public String generateOneSequence() {
		StringBuilder sequenceBuilder = new StringBuilder();
		
		for (Segment segment : this.getSegments()) {
			
			sequenceBuilder.append(segment.generate());
			
		}
		
		return sequenceBuilder.toString();
		
	}

	/**
	 * Generate many sequences.
	 */
	public List<String> generateManySequences(int replicates) {
	
		List<String> results = new ArrayList<>();
		
		while (replicates > 0) {
			
			results.add(this.generateOneSequence());
			
			replicates--;
			
		}
		
		return results;
		
	}
	
	/**
	 * Adds a new segment to the segment list.
	 * 
	 * @param segment ths segment to be added.
	 */
	public void addSegment(Segment segment) {
		
		this.getSegments().add(segment);
		
	}
	
	/**
	 * Removes a Segment from the segment list.
	 * 
	 * @param index of the segment to be removed in the segment list
	 */
	public Segment removeSegment(int index) {
		
		return this.getSegments().remove(index);
		
	}

	/**
	 * Removes all segment from the segment list.
	 */
	public void clearSegments() {

		this.getSegments().clear();
		
	}
	
	////////////////////////////////////
	// Getters and setters
	public List<Segment> getSegments() {
		return segments;
	}

	public void setSegments(List<Segment> segments) {
		this.segments = segments;
	}

}
